<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover â€” Free Image Resizer</title>

  <link rel="icon" href="../assets/favicon.png" />
  <meta name="description" content="Remove background from images locally (MediaPipe) â€” fast & lightweight." />

  <style>
    :root{
      --bg:#0d1524; --panel:#131d32; --muted:#a9b4c9; --accent:#1f9bff; --card:#0f1829; --border:#1d2944;
      --light:#dce7f7;
    }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, sans-serif;background:var(--bg);color:var(--light);}
    .container{max-width:1200px;margin:28px auto;padding:12px;}
    header.head{text-align:center;padding:18px 8px;}
    header.head h1{margin:0;font-size:30px;}
    header.head p{margin:6px 0;color:var(--muted);font-size:14px;}

    .br-wrapper{display:grid;grid-template-columns:360px 1fr;gap:24px;margin-top:18px;}
    @media(max-width:900px){.br-wrapper{grid-template-columns:1fr;padding:0 12px;}}

    .left-panel{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px}
    .drop-area{background:var(--card);border:2px dashed #33445a;border-radius:10px;padding:36px;text-align:center;cursor:pointer}
    .drop-area h3{margin:0;color:var(--light)}
    .note-small{color:var(--muted);font-size:13px;margin-top:6px}

    .btn{display:inline-block;padding:10px 14px;border-radius:8px;border:1px solid #324364;background:#1f2a44;color:var(--light);cursor:pointer}
    .btn.primary{background:var(--accent);border:none;color:#fff}
    .btn.small{padding:7px 10px;font-size:13px}
    .controls{margin-top:16px}

    /* right panel */
    .right-panel{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px;display:flex;align-items:center;justify-content:center}
    .preview-wrap{width:80%;max-width:720px;border-radius:10px;border:1px solid rgba(30,44,71,0.6);padding:24px;display:flex;align-items:center;justify-content:center;min-height:220px}
    canvas{max-width:100%;height:auto;border-radius:8px;background:transparent}

    .tip{color:var(--muted);font-size:13px;margin-top:12px}

    .row{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted);font-size:13px}
    .small-note{font-size:12px;color:var(--muted);margin-top:8px}
  </style>

  <!-- MediaPipe SelfieSegmentation -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
</head>
<body>
  <div class="container">
    <header class="head">
      <h1>AI Background Remover</h1>
      <p>Mode A â€” Fast, lightweight, humans-only (MediaPipe). Pure matting (no sliders) for best edges.</p>
    </header>

    <div class="br-wrapper">

      <!-- LEFT: controls -->
      <div class="left-panel">
        <div id="dropArea" class="drop-area" title="Click to open file browser or drop an image">
          <h3>Upload Image</h3>
          <p class="note-small">Drop or click to browse</p>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>

        <p class="note-small" style="text-align:center;margin:12px 0">OR</p>

        <button id="cameraBtn" class="btn" style="width:100%">ðŸ“· Capture from Camera</button>

        <div class="controls" id="controls" style="display:none">
          <div style="height:12px"></div>
          <div class="row">
            <button id="downloadBtn" class="btn primary">Download PNG</button>
            <button id="resetBtn" class="btn small">Reset</button>
            <div style="flex:1"></div>
          </div>
          <p class="small-note">Tip: Best results on photos with 1â€“2 people, plain backgrounds and good lighting.</p>
        </div>

      </div>

      <!-- RIGHT: preview -->
      <div class="right-panel">
        <div class="preview-wrap">
          <canvas id="previewCanvas" width="640" height="480"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* Single-file background remover:
   - MediaPipe SelfieSegmentation -> soft mask (0..1)
   - advancedMatting(maskFloat, workingCanvas) -> ImageData with alpha (removes halo)
   - Draw result to preview canvas scaled
*/

const fileInput = document.getElementById('fileInput');
const dropArea = document.getElementById('dropArea');
const cameraBtn = document.getElementById('cameraBtn');
const previewCanvas = document.getElementById('previewCanvas');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const controlsDiv = document.getElementById('controls');

const ctx = previewCanvas.getContext('2d');

let originalImg = null;
let workingImageCanvas = null; // resized source for segmentation & matting
let maskFloat = null; // Float32Array (0..1)
let maskW = 0, maskH = 0;
let selfieSeg = null;

const MAX_DIM = 1200; // cap for processing size

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function sizeFor(img){
  const w = img.naturalWidth || img.width;
  const h = img.naturalHeight || img.height;
  const max = Math.max(w,h);
  if(max <= MAX_DIM) return {w,h};
  const scale = MAX_DIM / max;
  return {w:Math.round(w*scale), h:Math.round(h*scale)};
}

/* Initialize MediaPipe SelfieSegmentation */
selfieSeg = new SelfieSegmentation({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
}});
selfieSeg.setOptions({modelSelection: 1});
selfieSeg.onResults(onSegmentationResult);

/* UI events */
dropArea.addEventListener('click', ()=> fileInput.click());
dropArea.addEventListener('dragover', (e)=>{ e.preventDefault(); dropArea.style.opacity = 0.9; });
dropArea.addEventListener('dragleave', ()=>{ dropArea.style.opacity = 1; });
dropArea.addEventListener('drop', (e)=>{ e.preventDefault(); dropArea.style.opacity = 1; if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });

fileInput.addEventListener('change', ()=> { if(fileInput.files && fileInput.files[0]) handleFile(fileInput.files[0]); });

cameraBtn.addEventListener('click', ()=> {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = 'image/*';
  inp.capture = 'environment';
  inp.onchange = ()=> { if(inp.files && inp.files[0]) handleFile(inp.files[0]); };
  inp.click();
});

downloadBtn.addEventListener('click', ()=> {
  previewCanvas.toBlob(blob => {
    if(!blob) return alert('Failed to prepare PNG.');
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'bg-removed.png';
    a.click();
  }, 'image/png');
});

resetBtn.addEventListener('click', ()=> {
  if(!originalImg) return;
  drawOriginalToCanvas(originalImg);
  processImageForMask(workingImageCanvas);
});

/* File handling */
async function handleFile(file){
  if(!file || !file.type.startsWith('image/')) { alert('Please choose an image file'); return; }
  const img = new Image();
  img.onload = async () => {
    originalImg = img;
    // prepare working canvas (resized for speed)
    const sz = sizeFor(img);
    workingImageCanvas = document.createElement('canvas');
    workingImageCanvas.width = sz.w;
    workingImageCanvas.height = sz.h;
    const wc = workingImageCanvas.getContext('2d');
    wc.drawImage(img, 0, 0, sz.w, sz.h);

    // show controls and draw original preview while segmentation runs
    controlsDiv.style.display = 'block';
    drawOriginalToCanvas(img);

    // run segmentation
    await processImageForMask(workingImageCanvas);
  };
  img.onerror = ()=> alert('Failed to load image');
  img.src = URL.createObjectURL(file);
}

/* Draw original image (fits preview area) */
function drawOriginalToCanvas(img){
  const sz = workingImageCanvas ? {w:workingImageCanvas.width,h:workingImageCanvas.height} : sizeFor(img);
  previewCanvas.width = Math.min(sz.w, 900);
  previewCanvas.height = Math.round(previewCanvas.width * (sz.h / sz.w));
  const dctx = previewCanvas.getContext('2d');
  dctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
  if(workingImageCanvas){
    dctx.drawImage(workingImageCanvas, 0,0, workingImageCanvas.width, workingImageCanvas.height, 0,0, previewCanvas.width, previewCanvas.height);
  } else {
    dctx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
  }
}

/* Process image for mask using MediaPipe */
async function processImageForMask(source){
  try {
    // MediaPipe accepts canvas or image
    await selfieSeg.send({image: source});
  } catch(err){
    console.error('Segmentation error', err);
    alert('Segmentation failed: ' + (err.message || err));
  }
}

/* onResults from MediaPipe */
async function onSegmentationResult(results){
  if(!results.segmentationMask){
    console.warn('No segmentationMask');
    return;
  }

  // draw mask into a canvas sized to workingImageCanvas
  maskW = workingImageCanvas.width;
  maskH = workingImageCanvas.height;
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = maskW;
  maskCanvas.height = maskH;
  const mctx = maskCanvas.getContext('2d');
  mctx.drawImage(results.segmentationMask, 0, 0, maskW, maskH);

  // extract grayscale (R) -> float mask 0..1
  const md = mctx.getImageData(0,0,maskW,maskH).data;
  maskFloat = new Float32Array(maskW * maskH);
  for(let i=0, j=0;i<md.length;i+=4,j++){
    maskFloat[j] = md[i] / 255; // use red channel, 0..1
  }

  // small morphological cleanup to remove holes (radius 1)
  maskFloat = morphClean(maskFloat, maskW, maskH, 1);

  // advanced matting pass -> ImageData with alpha channel
  const matteImageData = advancedMatting(workingImageCanvas, maskFloat, maskW, maskH);

  // draw matteImageData into preview canvas scaled to fit
  // create a temporary canvas to hold the result then scale into preview
  const outCanvas = document.createElement('canvas');
  outCanvas.width = maskW;
  outCanvas.height = maskH;
  const outCtx = outCanvas.getContext('2d');
  outCtx.putImageData(matteImageData, 0, 0);

  // scale to preview canvas
  const PREVIEW_MAX_W = Math.min(900, maskW);
  const scale = PREVIEW_MAX_W / maskW;
  previewCanvas.width = Math.round(maskW * scale);
  previewCanvas.height = Math.round(maskH * scale);
  ctx.clearRect(0,0, previewCanvas.width, previewCanvas.height);
  // draw with smoothing
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(outCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
}

/* simple morphological clean (dilate then erode) */
function morphClean(mask, w, h, radius){
  if(radius <= 0) return mask;
  const dil = new Float32Array(w*h);
  const r = radius;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let maxv = 0;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = mask[base + xx];
          if(v > maxv) maxv = v;
          if(maxv >= 1) break;
        }
        if(maxv >= 1) break;
      }
      dil[y*w + x] = maxv;
    }
  }
  const ero = new Float32Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let minv = 1;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = dil[base + xx];
          if(v < minv) minv = v;
          if(minv <= 0) break;
        }
        if(minv <= 0) break;
      }
      ero[y*w + x] = minv;
    }
  }
  return ero;
}

/* Advanced matting:
   - originalCanvas: source image canvas (workingImageCanvas)
   - maskArray: Float32Array (0..1)
   - returns ImageData(width,height) with correct alpha (0..255)
*/
function advancedMatting(originalCanvas, maskArray, width, height) {
  // draw original into temp canvas (ensure same size)
  const tmp = document.createElement('canvas');
  tmp.width = width;
  tmp.height = height;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(originalCanvas, 0, 0, width, height);

  const src = tctx.getImageData(0,0,width,height);
  const dst = tctx.createImageData(width, height);

  // compute average background color from four corners (small square)
  const sampleOffset = 6;
  let sumR=0,sumG=0,sumB=0, samples=0;
  const points = [
    [sampleOffset, sampleOffset],
    [width - sampleOffset - 1, sampleOffset],
    [sampleOffset, height - sampleOffset - 1],
    [width - sampleOffset - 1, height - sampleOffset - 1]
  ];
  points.forEach(([x,y])=>{
    const idx = (y * width + x) * 4;
    sumR += src.data[idx];
    sumG += src.data[idx+1];
    sumB += src.data[idx+2];
    samples++;
  });
  const bgR = sumR / samples;
  const bgG = sumG / samples;
  const bgB = sumB / samples;

  // constants for matting tuning
  const DIST_THRESHOLD = 60;   // color distance threshold from bg
  const HALO_REDUCTION = 130;  // reduce alpha for likely halo pixels
  const SOFTEN_RANGE = 60;     // how soft/transition

  // produce per-pixel alpha using mask and color-distance heuristics
  for(let i=0;i<width*height;i++){
    const si = i*4;
    const r = src.data[si], g = src.data[si+1], b = src.data[si+2];
    // base mask (0..1)
    const m = clamp(maskArray[i] || 0, 0, 1);
    // compute color distance to estimated bg color
    const dist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);

    // convert m -> baseAlpha (0..255)
    let baseAlpha = Math.round(m * 255);

    // If pixel is close to background color and mask is uncertain, reduce alpha to remove halo
    if(dist < DIST_THRESHOLD && baseAlpha < 230) {
      // scale reduction based on how close to bg color. Closer => more reduction.
      const reduce = Math.round(((DIST_THRESHOLD - dist) / DIST_THRESHOLD) * HALO_REDUCTION);
      baseAlpha = baseAlpha - reduce;
    }

    // Soft transition (optional gentle feathering near boundary)
    // if mask is partially transparent, slightly ramp alpha to avoid hard edge
    if(baseAlpha > 0 && baseAlpha < 255) {
      // increase alpha slightly based on original mask strength to avoid too thin hair
      const ramp = Math.round((m) * 30); // small boost
      baseAlpha = clamp(baseAlpha + ramp, 0, 255);
    }

    // clamp and write
    dst.data[si]   = r;
    dst.data[si+1] = g;
    dst.data[si+2] = b;
    dst.data[si+3] = clamp(Math.round(baseAlpha), 0, 255);
  }

  // Optional mild blur pass on alpha to smooth edges in the output image data.
  // We'll do a separable box blur on alpha channel (lightweight).
  boxBlurAlpha(dst, width, height, 1);

  return dst;
}

/* lightweight box blur applied to alpha channel only */
function boxBlurAlpha(imageData, w, h, radius) {
  if(radius <= 0) return;
  const src = imageData.data;
  const tmp = new Uint8ClampedArray(src.length);
  tmp.set(src);

  // horizontal pass
  const window = radius*2 + 1;
  for(let y=0;y<h;y++){
    let sum = 0;
    // initial window
    for(let x=-radius; x<=radius; x++){
      const xi = clamp(x,0,w-1);
      sum += tmp[(y*w + xi)*4 + 3];
    }
    for(let x=0;x<w;x++){
      const dstIdx = (y*w + x)*4 + 3;
      src[dstIdx] = Math.round(sum / window);
      // slide window
      const outX = x - radius;
      const inX = x + radius + 1;
      if(outX >= 0) sum -= tmp[(y*w + outX)*4 + 3];
      if(inX < w) sum += tmp[(y*w + inX)*4 + 3];
    }
  }

  // vertical pass (use tmp as source, src as destination)
  tmp.set(src); // copy current alpha
  for(let x=0;x<w;x++){
    let sum = 0;
    for(let y=-radius; y<=radius; y++){
      const yi = clamp(y,0,h-1);
      sum += tmp[(yi*w + x)*4 + 3];
    }
    for(let y=0;y<h;y++){
      const dstIdx = (y*w + x)*4 + 3;
      src[dstIdx] = Math.round(sum / window);
      const outY = y - radius;
      const inY = y + radius + 1;
      if(outY >= 0) sum -= tmp[(outY*w + x)*4 + 3];
      if(inY < h) sum += tmp[(inY*w + x)*4 + 3];
    }
  }
}

/* Warmup (non-blocking) */
(async function warmup(){
  const tmp = document.createElement('canvas');
  tmp.width = 10; tmp.height = 10;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = 'black'; tctx.fillRect(0,0,10,10);
  try {
    if(selfieSeg.initialize) await selfieSeg.initialize();
  } catch(e) {
    console.warn('Warmup failed', e);
  }
})();
</script>
</body>
</html>

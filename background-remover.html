<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover â€” Free Image Resizer</title>

  <link rel="icon" href="../assets/favicon.png" />
  <meta name="description" content="Remove background from images locally (MediaPipe) â€” fast & lightweight." />

  <style>
    :root{
      --bg:#0d1524; --panel:#131d32; --muted:#a9b4c9; --accent:#1f9bff; --card:#0f1829; --border:#1d2944;
      --light:#dce7f7;
    }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, sans-serif;background:var(--bg);color:var(--light);}
    .container{max-width:1200px;margin:28px auto;padding:12px;}
    header.head{text-align:center;padding:18px 8px;}
    header.head h1{margin:0;font-size:30px;}
    header.head p{margin:6px 0;color:var(--muted);font-size:14px;}

    .br-wrapper{display:grid;grid-template-columns:360px 1fr;gap:24px;margin-top:18px;}
    @media(max-width:900px){.br-wrapper{grid-template-columns:1fr;padding:0 12px;}}

    .left-panel{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px}
    .drop-area{background:var(--card);border:2px dashed #33445a;border-radius:10px;padding:36px;text-align:center;cursor:pointer}
    .drop-area h3{margin:0;color:var(--light)}
    .note-small{color:var(--muted);font-size:13px;margin-top:6px}

    .btn{display:inline-block;padding:10px 14px;border-radius:8px;border:1px solid #324364;background:#1f2a44;color:var(--light);cursor:pointer}
    .btn.primary{background:var(--accent);border:none;color:#fff}
    .btn.small{padding:7px 10px;font-size:13px}
    .controls{margin-top:16px}

    .control-label{color:var(--accent);font-weight:600;margin:10px 0 6px;display:block}
    input[type="range"]{width:100%}

    .right-panel{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px;display:flex;align-items:center;justify-content:center}
    .preview-wrap{width:80%;max-width:720px;border-radius:10px;border:1px solid rgba(30,44,71,0.6);padding:12px;display:flex;align-items:center;justify-content:center;min-height:220px}
    canvas{max-width:100%;height:auto;border-radius:8px;background:transparent}

    .tip{color:var(--muted);font-size:13px;margin-top:12px}

    .row{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted);font-size:13px}

    /* small loading indicator */
    #loading { display:none; margin-top:12px; color:var(--muted); font-size:13px; }
    #loading.show { display:block; }
  </style>

  <!-- MediaPipe SelfieSegmentation -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
</head>
<body>
  <div class="container">
    <header class="head">
      <h1>AI Background Remover</h1>
      <p>Mode A â€” Fast, lightweight, humans-only (MediaPipe). Upload or capture, then refine edges.</p>
    </header>

    <div class="br-wrapper">

      <!-- LEFT: controls -->
      <div class="left-panel">
        <div id="dropArea" class="drop-area" title="Click to open file browser or drop an image">
          <h3>Upload Image</h3>
          <p class="note-small">Drop or click to browse</p>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>

        <p class="note-small" style="text-align:center;margin:12px 0">OR</p>

        <button id="cameraBtn" class="btn" style="width:100%">ðŸ“· Capture from Camera</button>

        <div id="loading" class="">Model warmup â€” ready when indicated.</div>

        <div class="controls" id="controls" style="display:none">

          <label class="control-label">Refine output</label>
          <div class="muted">Edge smoothing</div>
          <input id="blurRange" type="range" min="0" max="24" value="4">

          <div style="height:10px"></div>
          <div class="muted">Mask opacity (for softer edges)</div>
          <input id="opacityRange" type="range" min="60" max="255" value="255">

          <div style="height:12px"></div>
          <div class="row">
            <button id="downloadBtn" class="btn primary">Download PNG</button>
            <button id="resetBtn" class="btn small">Reset</button>
            <div style="flex:1"></div>
          </div>

          <p class="tip">Works best for photos with 1â€“2 people, plain backgrounds and decent lighting. Use blur to smooth edges. Reset to re-run.</p>
        </div>

      </div>

      <!-- RIGHT: preview -->
      <div class="right-panel">
        <div class="preview-wrap">
          <canvas id="previewCanvas"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* ===========================
   Single-file MediaPipe pipeline (Option B)
   - MediaPipe SelfieSegmentation
   - Morphological cleanup
   - Advanced matting pass (reduces halos)
   - GPU blur for feathering
   - Final alpha-preserving compositing & download PNG
   =========================== */

const fileInput = document.getElementById('fileInput');
const dropArea = document.getElementById('dropArea');
const cameraBtn = document.getElementById('cameraBtn');
const previewCanvas = document.getElementById('previewCanvas');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const controlsDiv = document.getElementById('controls');
const blurRange = document.getElementById('blurRange');
const opacityRange = document.getElementById('opacityRange');
const loadingEl = document.getElementById('loading');

const ctx = previewCanvas.getContext('2d');

let originalImg = null;              // HTMLImageElement
let workingImageCanvas = null;       // resized source for segmentation
let maskFloat = null;                // Float32Array 0..1
let maskW = 0, maskH = 0;
let selfieSeg = null;

const MAX_DIM = 1200; // processing dimension cap

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function sizeFor(img){
  const w = img.naturalWidth || img.width;
  const h = img.naturalHeight || img.height;
  const max = Math.max(w,h);
  if(max <= MAX_DIM) return {w,h};
  const scale = MAX_DIM / max;
  return {w:Math.round(w*scale), h:Math.round(h*scale)};
}

/* ---------- initialize MediaPipe SelfieSegmentation ---------- */
selfieSeg = new SelfieSegmentation({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
}});
selfieSeg.setOptions({modelSelection: 1}); // 1 = general/higher-quality
selfieSeg.onResults(onSegmentationResult);

// Small warmup (non-blocking)
(async function warmup(){
  loadingEl.classList.add('show');
  loadingEl.textContent = 'Warming up model...';
  try{
    // send tiny canvas to warm backend (won't wait long)
    const tmp = document.createElement('canvas'); tmp.width=8; tmp.height=8;
    const tctx = tmp.getContext('2d'); tctx.fillStyle='black'; tctx.fillRect(0,0,8,8);
    await selfieSeg.send({image: tmp}).catch(()=>{});
    loadingEl.textContent = 'Model ready.';
    setTimeout(()=>loadingEl.classList.remove('show'), 900);
  }catch(e){
    loadingEl.textContent = 'Model ready (warmup skipped).';
    setTimeout(()=>loadingEl.classList.remove('show'), 900);
  }
})();

/* ---------- UI events ---------- */
dropArea.addEventListener('click', ()=>fileInput.click());
dropArea.addEventListener('dragover', (e)=>{ e.preventDefault(); dropArea.style.opacity = 0.9; });
dropArea.addEventListener('dragleave', ()=>{ dropArea.style.opacity = 1; });
dropArea.addEventListener('drop', (e)=>{ e.preventDefault(); dropArea.style.opacity = 1; if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });

fileInput.addEventListener('change', ()=>{ if(fileInput.files && fileInput.files[0]) handleFile(fileInput.files[0]); });

cameraBtn.addEventListener('click', ()=> {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = 'image/*';
  inp.capture = 'environment';
  inp.onchange = ()=> { if(inp.files && inp.files[0]) handleFile(inp.files[0]); };
  inp.click();
});

downloadBtn.addEventListener('click', ()=> {
  previewCanvas.toBlob(blob=>{
    if(!blob) return alert('Failed to prepare PNG.');
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'bg-removed.png';
    a.click();
  }, 'image/png');
});

resetBtn.addEventListener('click', ()=> {
  if(!originalImg) return;
  drawOriginalToCanvas(originalImg);
  processImageForMask(workingImageCanvas);
});

blurRange.addEventListener('input', ()=> { if(maskFloat) renderComposite(); });
opacityRange.addEventListener('input', ()=> { if(maskFloat) renderComposite(); });

/* ---------- handle file ---------- */
async function handleFile(file){
  if(!file || !file.type.startsWith('image/')) { alert('Please choose an image file'); return; }
  loadingEl.classList.add('show'); loadingEl.textContent = 'Loading image...';
  const img = new Image();
  img.onload = async ()=>{
    originalImg = img;
    // resize into working canvas for segmentation (speed & memory)
    const sz = sizeFor(img);
    workingImageCanvas = document.createElement('canvas');
    workingImageCanvas.width = sz.w;
    workingImageCanvas.height = sz.h;
    workingImageCanvas.getContext('2d').drawImage(img,0,0,sz.w,sz.h);
    drawOriginalToCanvas(img);
    controlsDiv.style.display = 'block';
    await processImageForMask(workingImageCanvas);
    loadingEl.classList.remove('show');
  };
  img.onerror = ()=>{ loadingEl.classList.remove('show'); alert('Failed to load image'); };
  img.src = URL.createObjectURL(file);
}

/* ---------- draw original image (fit preview) ---------- */
function drawOriginalToCanvas(img){
  const sz = workingImageCanvas ? {w:workingImageCanvas.width,h:workingImageCanvas.height} : sizeFor(img);
  const PREVIEW_MAX_W = Math.min(900, sz.w);
  const scale = PREVIEW_MAX_W / sz.w;
  previewCanvas.width = Math.round(sz.w * scale);
  previewCanvas.height = Math.round(sz.h * scale);
  const drawCtx = previewCanvas.getContext('2d');
  drawCtx.clearRect(0,0, previewCanvas.width, previewCanvas.height);
  if(workingImageCanvas){
    drawCtx.drawImage(workingImageCanvas, 0, 0, workingImageCanvas.width, workingImageCanvas.height, 0, 0, previewCanvas.width, previewCanvas.height);
  } else {
    drawCtx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
  }
}

/* ---------- segmentation ---------- */
async function processImageForMask(source){
  try {
    loadingEl.classList.add('show'); loadingEl.textContent = 'Running segmentation...';
    // MediaPipe accepts an HTMLCanvasElement or ImageBitmap
    await selfieSeg.send({image: source});
    loadingEl.classList.remove('show');
  } catch(err){
    loadingEl.classList.remove('show');
    console.error(err);
    alert('Segmentation failed: ' + (err.message || err));
  }
}

/* ---------- on segmentation result ---------- */
function onSegmentationResult(results){
  if(!results.segmentationMask){
    console.warn('No segmentation mask returned');
    return;
  }

  maskW = workingImageCanvas.width;
  maskH = workingImageCanvas.height;
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = maskW;
  maskCanvas.height = maskH;
  const mctx = maskCanvas.getContext('2d');
  mctx.drawImage(results.segmentationMask, 0, 0, maskW, maskH);

  const md = mctx.getImageData(0,0,maskW,maskH).data;
  maskFloat = new Float32Array(maskW * maskH);
  for(let i=0,j=0;i<md.length;i+=4,j++){
    maskFloat[j] = md[i] / 255; // R channel
  }

  // morphological cleanup (small radius)
  maskFloat = morphClean(maskFloat, maskW, maskH, 1);

  // render final composite
  renderComposite();
}

/* ---------- morphological clean (dilate then erode) ---------- */
function morphClean(mask, w, h, radius){
  if(radius <= 0) return mask;
  const dil = new Float32Array(w*h);
  const r = radius;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let maxv = 0;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = mask[base + xx];
          if(v > maxv) maxv = v;
          if(maxv >= 1) break;
        }
        if(maxv >= 1) break;
      }
      dil[y*w + x] = maxv;
    }
  }
  const ero = new Float32Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let minv = 1;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = dil[base + xx];
          if(v < minv) minv = v;
          if(minv <= 0) break;
        }
        if(minv <= 0) break;
      }
      ero[y*w + x] = minv;
    }
  }
  return ero;
}

/* ---------- advanced matting: returns ImageData with refined alpha ---------- */
function advancedMatting(originalCanvas, maskArray, width, height) {
  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = width;
  tmpCanvas.height = height;
  const tctx = tmpCanvas.getContext("2d");
  tctx.drawImage(originalCanvas, 0, 0, width, height);

  const src = tctx.getImageData(0, 0, width, height);
  const dst = tctx.createImageData(width, height);

  // Sample average background color from corners (safely)
  let sumR = 0, sumG = 0, sumB = 0, count = 0;
  const margin = Math.max(2, Math.floor(Math.min(width, height) * 0.02));
  const points = [
    [margin, margin],
    [width - margin - 1, margin],
    [margin, height - margin - 1],
    [width - margin - 1, height - margin - 1]
  ];
  points.forEach(([x,y])=>{
    const idx = (y * width + x) * 4;
    sumR += src.data[idx];
    sumG += src.data[idx+1];
    sumB += src.data[idx+2];
    count++;
  });
  const bgR = sumR / count, bgG = sumG / count, bgB = sumB / count;

  for (let i = 0; i < width * height; i++) {
    const idx = i * 4;
    const r = src.data[idx], g = src.data[idx+1], b = src.data[idx+2];
    const baseAlpha = Math.round(clamp(maskArray[i],0,1) * 255);

    // color distance heuristic
    const dist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);

    let alpha = baseAlpha;

    // soften halos for pixels close to background color and partially transparent mask
    if (dist < 55 && baseAlpha < 220) {
      // reduce halo by a subtraction scaled by how close to bg color (closer -> bigger subtraction)
      const removal = Math.round((55 - dist) * 2.2); // tuned factor
      alpha = Math.max(0, baseAlpha - removal);
    }

    // slightly boost alpha for hair-like pixels that are dark on mask edges
    if (baseAlpha > 60 && baseAlpha < 210 && dist > 40) {
      alpha = Math.min(255, Math.round(baseAlpha + 12));
    }

    dst.data[idx]   = r;
    dst.data[idx+1] = g;
    dst.data[idx+2] = b;
    dst.data[idx+3] = alpha;
  }

  return dst;
}

/* ---------- render composite: mask â†’ matting â†’ final preview ---------- */
function renderComposite(){
  if(!maskFloat || !workingImageCanvas) return;

  // create mask canvas at working resolution
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = maskW;
  maskCanvas.height = maskH;
  const mctx = maskCanvas.getContext('2d');
  const maskImg = mctx.createImageData(maskW, maskH);
  for(let i=0, j=0;i<maskImg.data.length;i+=4,j++){
    const v = clamp(Math.round(maskFloat[j]*255),0,255);
    maskImg.data[i] = v; maskImg.data[i+1] = v; maskImg.data[i+2] = v; maskImg.data[i+3] = 255;
  }
  mctx.putImageData(maskImg,0,0);

  // blur mask using GPU (canvas filter)
  const blurPx = parseInt(blurRange.value,10) || 0;
  if(blurPx > 0){
    const blurred = document.createElement('canvas');
    blurred.width = maskW; blurred.height = maskH;
    const bctx = blurred.getContext('2d');
    bctx.filter = `blur(${blurPx}px)`;
    bctx.drawImage(maskCanvas,0,0);
    // copy back
    mctx.clearRect(0,0, maskW, maskH);
    mctx.drawImage(blurred,0,0);
  }

  // read blurred mask into Float
  const mdata = mctx.getImageData(0,0,maskW,maskH).data;
  const finalMaskFloat = new Float32Array(maskW*maskH);
  for(let i=0,j=0;i<mdata.length;i+=4,j++){
    finalMaskFloat[j] = mdata[i] / 255;
  }

  // apply advanced matting: we pass original working canvas and the mask
  const matImageData = advancedMatting(workingImageCanvas, finalMaskFloat, maskW, maskH);

  // apply opacity slider (scale alpha)
  const op = Number(opacityRange.value) / 255.0;
  for(let i=0;i<matImageData.data.length;i+=4){
    matImageData.data[i+3] = Math.round(matImageData.data[i+3] * op);
  }

  // create final out canvas at working resolution & put the mat image data (contains alpha)
  const outCanvas = document.createElement('canvas');
  outCanvas.width = maskW; outCanvas.height = maskH;
  const outCtx = outCanvas.getContext('2d');
  outCtx.putImageData(matImageData, 0, 0);

  // Draw onto preview canvas scaled to fit (preserve alpha)
  const PREVIEW_MAX_W = Math.min(900, maskW);
  const scale = PREVIEW_MAX_W / maskW;
  previewCanvas.width = Math.round(maskW * scale);
  previewCanvas.height = Math.round(maskH * scale);
  ctx.clearRect(0,0, previewCanvas.width, previewCanvas.height);
  ctx.drawImage(outCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
}

/* ---------- end ---------- */
</script>
</body>
</html>

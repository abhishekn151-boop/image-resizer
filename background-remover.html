<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover â€” Free Image Resizer</title>

  <!-- Theme CSS (your global stylesheet) -->
  <link rel="stylesheet" href="../style.css" />

  <!-- Page-local styles -->
  <style>
    /* --- compact page styles (matches your dark theme) --- */
    :root {
      --panel-bg: #131d32;
      --box-bg: #0f1829;
      --muted: #a9b4c9;
      --accent: #4ad2ff;
      --btn: #1f9bff;
      --panel-border: #1d2944;
    }

    .br-root {
      max-width: 1200px;
      margin: 18px auto 80px;
      padding: 20px;
    }

    .br-title {
      text-align: center;
      margin-bottom: 18px;
    }
    .br-title h1 { font-size: 32px; margin-bottom:6px; }
    .br-title p { color: var(--muted); margin-top:6px; }

    .br-grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 28px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .br-grid { grid-template-columns: 1fr; padding: 0 12px; }
    }

    /* left panel */
    .br-left {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 18px;
    }

    #drop-area {
      background: var(--box-bg);
      border: 2px dashed #3a4459;
      border-radius: 12px;
      padding: 28px 16px;
      text-align: center;
      cursor: pointer;
      transition: 0.18s;
    }
    #drop-area:hover { border-color: var(--accent); background: #102742; }
    #drop-area h3 { margin-bottom:6px; }
    .note-small { color: var(--muted); font-size: 13px; margin-top:6px; }

    .br-btn {
      width:100%;
      margin-top:12px;
      background: #1f2a44;
      border: 1px solid #324364;
      color: #dae7ff;
      border-radius: 10px;
      padding: 12px;
      cursor: pointer;
      transition:0.15s;
    }
    .br-btn:hover { background:#273556; }

    .controls {
      margin-top: 18px;
      border-top: 1px solid var(--panel-border);
      padding-top: 14px;
    }
    .controls h4 { color: var(--accent); margin-bottom:8px; }
    .controls label { display:block; color:var(--muted); margin:8px 0 6px; font-size:0.95rem; }
    .controls input[type="range"] { width:100%; }

    .small-row { display:flex; gap:8px; margin-top:12px; }
    .small-row button { flex:1; padding:10px; border-radius:8px; border:none; cursor:pointer; }
    .primary { background: var(--btn); color:white; border: none; }
    .muted { background: #243249; color: #d8e9ff; border: 1px solid #324364; }

    /* right preview */
    .br-right {
      background: var(--box-bg);
      border:1px solid var(--panel-border);
      border-radius:12px;
      padding: 18px;
      min-height: 420px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .preview-wrap {
      width: 70%;
      max-width: 640px;
      aspect-ratio: 3/2;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.02);
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid #1e2c47;
    }

    canvas#outputCanvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display:block;
      background: transparent;
    }

    .helper {
      color: var(--muted);
      font-size: 13px;
      text-align:center;
      margin-top: 10px;
    }

    .hidden { display:none !important; }

    /* overlay loading */
    .loading-overlay {
      position: fixed;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(6,8,12,0.55);
      z-index: 9999;
    }
    .loader {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      padding: 16px 20px;
      border-radius: 10px;
      display:flex;
      gap:12px;
      align-items:center;
    }
    .loader .dot {
      width:14px; height:14px; border-radius:50%;
      background:var(--accent); animation: blink 1s infinite;
    }
    @keyframes blink { 0% { opacity:.2 } 50% { opacity:1 } 100% { opacity:.2 } }

    /* small footer */
    .br-footer { text-align:center; margin-top:18px; color:var(--muted); font-size:13px; }
  </style>

  <!-- MediaPipe Selfie Segmentation (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

  <!-- your site navbar is expected to be injected as you already do -->
  <div id="navbar"></div>

  <div class="br-root">
    <div class="br-title">
      <h1>AI Background Remover</h1>
      <p class="tagline">Mode A â€” Remove background completely (transparent PNG). Fast & lightweight (MediaPipe).</p>
    </div>

    <div class="br-grid">
      <!-- LEFT -->
      <div class="br-left">
        <div id="drop-area">
          <h3>Upload Image</h3>
          <p class="note-small">Drop or click to browse</p>
          <input id="fileInput" type="file" accept="image/*" style="display:none">
        </div>

        <p class="note-small" style="text-align:center; margin:10px 0;">OR</p>

        <button id="cameraBtn" class="br-btn">ðŸ“· Capture from Camera</button>

        <div class="controls hidden" id="controlsPanel">
          <h4>Refine output</h4>

          <label for="blurRange">Edge smoothing</label>
          <input id="blurRange" type="range" min="0" max="12" value="3">

          <label for="alphaRange">Mask opacity (for softer edges)</label>
          <input id="alphaRange" type="range" min="80" max="255" value="255">

          <div class="small-row" style="margin-top:12px">
            <button id="downloadBtn" class="primary">Download PNG</button>
            <button id="resetBtn" class="muted">Reset</button>
          </div>
        </div>

        <div class="br-footer" style="margin-top:14px">
          Tip: Works best for photos with one or two people, plain backgrounds, and decent lighting.
        </div>
      </div>

      <!-- RIGHT -->
      <div class="br-right">
        <div class="preview-wrap" id="previewWrap">
          <canvas id="outputCanvas" width="640" height="480"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loading" class="loading-overlay hidden">
    <div class="loader">
      <div class="dot"></div>
      <div style="color:#dce7f7">Processing â€” AI segmentation</div>
    </div>
  </div>

  <!-- Footer year -->
  <script> if(document.getElementById('year')) document.getElementById('year').textContent = new Date().getFullYear(); </script>

  <!-- MAIN JS (MediaPipe SelfieSeg + image flow) -->
  <script>
  (function () {
    // Elements
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('fileInput');
    const cameraBtn = document.getElementById('cameraBtn');
    const outputCanvas = document.getElementById('outputCanvas');
    const ctx = outputCanvas.getContext('2d', { willReadFrequently: true });
    const controlsPanel = document.getElementById('controlsPanel');
    const blurRange = document.getElementById('blurRange');
    const alphaRange = document.getElementById('alphaRange');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');
    const loading = document.getElementById('loading');

    let lastImage = null;   // HTMLImageElement
    let cameraStream = null;
    let mpCamera = null;
    let selfieSeg = null;
    let busy = false;

    // UTIL: show/hide loader
    function showLoading(v=true) { loading.classList.toggle('hidden', !v); }
    function enableControls(v) { controlsPanel.classList.toggle('hidden', !v); }

    // initialize MediaPipe SelfieSeg
    async function initModel() {
      selfieSeg = new SelfieSegmentation({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
      });

      selfieSeg.setOptions({
        modelSelection: 1, // 0-general, 1-higher quality for multiple people (choose 1)
      });

      selfieSeg.onResults(onResults);
    }

    // compositing result: take original image, segmentation mask (in results), and produce RGBA w/ transparent background
    async function onResults(results) {
      // results.segmentationMask is a HTMLCanvasElement (MediaPipe supplies)
      const mask = results.segmentationMask;
      const src = results.image; // ImageBitmap / HTMLImageElement / HTMLVideoElement

      if (!mask || !src) return;

      // ensure canvas size matches image
      const w = src.width || src.videoWidth;
      const h = src.height || src.videoHeight;
      outputCanvas.width = w;
      outputCanvas.height = h;

      // draw original image to temp canvas
      const tmp = document.createElement('canvas');
      tmp.width = w; tmp.height = h;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(src, 0, 0, w, h);

      // draw segmentation mask to another canvas (mask is already a canvas)
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = mask.width || w;
      maskCanvas.height = mask.height || h;
      const mctx = maskCanvas.getContext('2d');
      // mask returned by MediaPipe can be different dimension - draw scaled
      mctx.drawImage(mask, 0, 0, maskCanvas.width, maskCanvas.height);

      // Optional smoothing: blur the mask into a new canvas
      const blur = Number(blurRange.value) || 0;
      if (blur > 0) {
        // apply blur filter by drawing into another canvas with context.filter
        const blurred = document.createElement('canvas');
        blurred.width = maskCanvas.width; blurred.height = maskCanvas.height;
        const bctx = blurred.getContext('2d');
        bctx.filter = `blur(${blur}px)`;
        bctx.drawImage(maskCanvas, 0, 0);
        bctx.filter = 'none';
        // replace maskCanvas
        maskCanvas.width = blurred.width;
        maskCanvas.height = blurred.height;
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(blurred, 0, 0);
      }

      // read image + mask pixel data
      const srcData = tctx.getImageData(0,0,w,h);
      const maskData = mctx.getImageData(0,0,maskCanvas.width,maskCanvas.height);

      // If mask canvas is scaled, map coordinates accordingly
      // We'll map mask pixel by proportional coordinates
      const final = ctx.createImageData(w,h);
      const alphaLimit = Number(alphaRange.value) || 255;

      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const i = (y*w + x) * 4;
          // get mask pixel from maskData with scaling
          const mx = Math.floor(x * (maskCanvas.width / w));
          const my = Math.floor(y * (maskCanvas.height / h));
          const mi = (my*maskCanvas.width + mx) * 4;
          // mask's R channel contains the score (0..255)
          const maskVal = maskData.data[mi]; // 0..255

          // If maskVal > threshold -> keep pixel (person). Otherwise transparent.
          // We use maskVal directly to produce soft alpha
          const keepAlpha = Math.round((maskVal / 255) * alphaLimit);

          final.data[i] = srcData.data[i];
          final.data[i+1] = srcData.data[i+1];
          final.data[i+2] = srcData.data[i+2];
          final.data[i+3] = keepAlpha;
        }
      }

      // put final to output canvas
      ctx.clearRect(0,0, w, h);
      ctx.putImageData(final, 0, 0);
      busy = false;
      showLoading(false);
      enableControls(true);
    }

    // send a static image to model
    async function processImage(img) {
      if (!selfieSeg) await initModel();
      busy = true;
      showLoading(true);
      enableControls(false);

      // results callback will handle compositing
      await selfieSeg.send({image: img});
    }

    // handle file input
    dropArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      stopCameraIfRunning();
      loadImageFile(f);
      fileInput.value = '';
    });

    // drag-and-drop
    dropArea.addEventListener('dragover', (e)=>{ e.preventDefault(); dropArea.classList.add('active'); });
    dropArea.addEventListener('dragleave', ()=> dropArea.classList.remove('active'));
    dropArea.addEventListener('drop', (e) => {
      e.preventDefault(); dropArea.classList.remove('active');
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (!f) return;
      stopCameraIfRunning();
      loadImageFile(f);
    });

    // load image from file into an Image element and process
    function loadImageFile(file) {
      const img = new Image();
      img.onload = () => {
        lastImage = img;
        processImage(img);
      };
      img.onerror = () => alert('Failed to load image.');
      img.src = URL.createObjectURL(file);
    }

    // Camera capture: use MediaPipe CameraUtils to continuously send frames until user stops.
    cameraBtn.addEventListener('click', async () => {
      // if camera running, stop it
      if (cameraStream) {
        stopCameraIfRunning();
        cameraBtn.textContent = 'ðŸ“· Capture from Camera';
        return;
      }

      // prepare video element
      const video = document.createElement('video');
      video.style.display = 'none';
      document.body.appendChild(video);

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio: false });
        cameraStream = stream;
        video.srcObject = stream;
        await video.play();

        // use MediaPipe's Camera helper to continuously send frames
        mpCamera = new Camera(video, {
          onFrame: async () => {
            if (!selfieSeg) await initModel();
            if (!busy) {
              busy = true;
              showLoading(true);
              enableControls(false);
              await selfieSeg.send({image: video});
            }
          },
          width: 1280,
          height: 720
        });
        mpCamera.start();
        cameraBtn.textContent = 'Stop Camera';
      } catch (err) {
        alert('Cannot access camera: ' + err.message);
        stopCameraIfRunning();
      }
    });

    function stopCameraIfRunning() {
      if (mpCamera && mpCamera.stop) {
        try { mpCamera.stop(); } catch(e) {}
        mpCamera = null;
      }
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      const vids = document.querySelectorAll('video');
      vids.forEach(v => { if (v && v.parentNode) v.parentNode.removeChild(v); });
      cameraBtn.textContent = 'ðŸ“· Capture from Camera';
    }

    // download
    downloadBtn.addEventListener('click', () => {
      if (!outputCanvas) return;
      const url = outputCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cutout.png';
      a.click();
    });

    resetBtn.addEventListener('click', () => {
      if (lastImage) {
        processImage(lastImage);
      } else {
        ctx.clearRect(0,0, outputCanvas.width, outputCanvas.height);
        enableControls(false);
      }
    });

    // small UI hooks: while blur/alpha change reprocess last image for instant preview
    let reprocessTimeout = null;
    function scheduleReprocess() {
      if (!lastImage) return;
      if (reprocessTimeout) clearTimeout(reprocessTimeout);
      reprocessTimeout = setTimeout(()=>{ processImage(lastImage); }, 180);
    }
    blurRange.addEventListener('input', scheduleReprocess);
    alphaRange.addEventListener('input', scheduleReprocess);

    // init model eagerly (optional) to reduce first-run latency
    initModel().then(()=> { /* model ready */ }).catch(e => console.error('Model init error', e));

    // clean up if user leaves page (stop camera)
    window.addEventListener('beforeunload', stopCameraIfRunning);

    // make sure navbar (if injected) doesn't block click events on drop area
    // (your navbar injection happens earlier; this is defensive)
    document.addEventListener('DOMContentLoaded', ()=> { if(typeof window.injectNavbar === 'function') window.injectNavbar(); });

  })();
  </script>

</body>
</html>

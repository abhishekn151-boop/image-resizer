<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover â€” Free Image Resizer</title>

  <link rel="icon" href="../assets/favicon.png" />
  <meta name="description" content="Remove background from images locally (MediaPipe) â€” fast & lightweight." />

  <style>
    :root{
      --bg:#0d1524; --panel:#131d32; --muted:#a9b4c9; --accent:#1f9bff; --card:#0f1829; --border:#1d2944;
      --light:#dce7f7;
    }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, sans-serif;background:var(--bg);color:var(--light);}
    .container{max-width:1200px;margin:28px auto;padding:12px;}
    header.head{text-align:center;padding:18px 8px;}
    header.head h1{margin:0;font-size:30px;}
    header.head p{margin:6px 0;color:var(--muted);font-size:14px;}

    .br-wrapper{display:grid;grid-template-columns:360px 1fr;gap:24px;margin-top:18px;}
    @media(max-width:900px){.br-wrapper{grid-template-columns:1fr;padding:0 12px;}}

    .left-panel{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px}
    .drop-area{background:var(--card);border:2px dashed #33445a;border-radius:10px;padding:36px;text-align:center;cursor:pointer}
    .drop-area h3{margin:0;color:var(--light)}
    .note-small{color:var(--muted);font-size:13px;margin-top:6px}

    .btn{display:inline-block;padding:10px 14px;border-radius:8px;border:1px solid #324364;background:#1f2a44;color:var(--light);cursor:pointer}
    .btn.primary{background:var(--accent);border:none;color:#fff}
    .btn.small{padding:7px 10px;font-size:13px}
    .controls{margin-top:16px}

    /* right panel */
    .right-panel{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:18px;min-height:380px;display:flex;align-items:center;justify-content:center}
    .preview-wrap{width:80%;max-width:720px;border-radius:10px;border:1px solid rgba(30,44,71,0.6);padding:24px;display:flex;align-items:center;justify-content:center;min-height:220px}
    canvas{max-width:100%;height:auto;border-radius:8px;background:transparent}

    .tip{color:var(--muted);font-size:13px;margin-top:12px}

    .row{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted);font-size:13px}
    .small-note{font-size:12px;color:var(--muted);margin-top:8px}
  </style>

  <!-- MediaPipe SelfieSegmentation -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
</head>
<body>
  <div class="container">
    <header class="head">
      <h1>AI Background Remover</h1>
      <p>Mode A â€” Fast, lightweight, humans-only (MediaPipe). Pure matting (no sliders) for best edges.</p>
    </header>

    <div class="br-wrapper">

      <!-- LEFT: controls -->
      <div class="left-panel">
        <div id="dropArea" class="drop-area" title="Click to open file browser or drop an image">
          <h3>Upload Image</h3>
          <p class="note-small">Drop or click to browse</p>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>

        <p class="note-small" style="text-align:center;margin:12px 0">OR</p>

        <button id="cameraBtn" class="btn" style="width:100%">ðŸ“· Capture from Camera</button>

        <div class="controls" id="controls" style="display:none">
          <div style="height:12px"></div>
          <div class="row">
            <button id="downloadBtn" class="btn primary">Download PNG</button>
            <button id="resetBtn" class="btn small">Reset</button>
            <div style="flex:1"></div>
          </div>
          <p class="small-note">Tip: Best results on photos with 1â€“2 people, plain backgrounds and good lighting.</p>
        </div>

      </div>

      <!-- RIGHT: preview -->
      <div class="right-panel">
        <div class="preview-wrap">
          <canvas id="previewCanvas" width="640" height="480"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* Single-file background remover:
   - MediaPipe SelfieSegmentation -> soft mask (0..1)
   - advancedMatting(maskFloat, workingCanvas) -> ImageData with alpha (removes halo)
   - Draw result to preview canvas scaled
*/

const fileInput = document.getElementById('fileInput');
const dropArea = document.getElementById('dropArea');
const cameraBtn = document.getElementById('cameraBtn');
const previewCanvas = document.getElementById('previewCanvas');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const controlsDiv = document.getElementById('controls');

const ctx = previewCanvas.getContext('2d');

let originalImg = null;
let workingImageCanvas = null; // resized source for segmentation & matting
let maskFloat = null; // Float32Array (0..1)
let maskW = 0, maskH = 0;
let selfieSeg = null;

const MAX_DIM = 1200; // cap for processing size

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function sizeFor(img){
  const w = img.naturalWidth || img.width;
  const h = img.naturalHeight || img.height;
  const max = Math.max(w,h);
  if(max <= MAX_DIM) return {w,h};
  const scale = MAX_DIM / max;
  return {w:Math.round(w*scale), h:Math.round(h*scale)};
}
  
  /* Resize maskFloat (segmentation mask) from small size â†’ full resolution */
function resizeMaskFloat(maskSmall, sw, sh, dw, dh) {
  const maskLarge = new Float32Array(dw * dh);
  for (let y = 0; y < dh; y++) {
    const sy = Math.floor((y / dh) * sh);
    for (let x = 0; x < dw; x++) {
      const sx = Math.floor((x / dw) * sw);
      maskLarge[y * dw + x] = maskSmall[sy * sw + sx];
    }
  }
  return maskLarge;
}

/* Initialize MediaPipe SelfieSegmentation */
selfieSeg = new SelfieSegmentation({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
}});
selfieSeg.setOptions({modelSelection: 1});
selfieSeg.onResults(onSegmentationResult);

/* UI events */
dropArea.addEventListener('click', ()=> fileInput.click());
dropArea.addEventListener('dragover', (e)=>{ e.preventDefault(); dropArea.style.opacity = 0.9; });
dropArea.addEventListener('dragleave', ()=>{ dropArea.style.opacity = 1; });
dropArea.addEventListener('drop', (e)=>{ e.preventDefault(); dropArea.style.opacity = 1; if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });

fileInput.addEventListener('change', ()=> { if(fileInput.files && fileInput.files[0]) handleFile(fileInput.files[0]); });

cameraBtn.addEventListener('click', ()=> {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = 'image/*';
  inp.capture = 'environment';
  inp.onchange = ()=> { if(inp.files && inp.files[0]) handleFile(inp.files[0]); };
  inp.click();
});

downloadBtn.addEventListener('click', ()=> {
  if (!window.finalOutputCanvas) return alert("Image not ready.");

  window.finalOutputCanvas.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'bg-removed.png';
    a.click();
  }, 'image/png');
});

resetBtn.addEventListener('click', ()=> {
  if(!originalImg) return;
  drawOriginalToCanvas(originalImg);
  processImageForMask(workingImageCanvas);
});

/* File handling */
async function handleFile(file){
  if(!file || !file.type.startsWith('image/')) { alert('Please choose an image file'); return; }
  const img = new Image();
  img.onload = async () => {
    originalImg = img;
    // prepare working canvas (resized for speed)
    const sz = sizeFor(img);
    workingImageCanvas = document.createElement('canvas');
    workingImageCanvas.width = sz.w;
    workingImageCanvas.height = sz.h;
    const wc = workingImageCanvas.getContext('2d');
    wc.drawImage(img, 0, 0, sz.w, sz.h);

    // show controls and draw original preview while segmentation runs
    controlsDiv.style.display = 'block';
    drawOriginalToCanvas(img);

    // run segmentation
    await processImageForMask(workingImageCanvas);
  };
  img.onerror = ()=> alert('Failed to load image');
  img.src = URL.createObjectURL(file);
}

/* Draw original image (fits preview area) */
function drawOriginalToCanvas(img){
  const sz = workingImageCanvas ? {w:workingImageCanvas.width,h:workingImageCanvas.height} : sizeFor(img);
  previewCanvas.width = Math.min(sz.w, 900);
  previewCanvas.height = Math.round(previewCanvas.width * (sz.h / sz.w));
  const dctx = previewCanvas.getContext('2d');
  dctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
  if(workingImageCanvas){
    dctx.drawImage(workingImageCanvas, 0,0, workingImageCanvas.width, workingImageCanvas.height, 0,0, previewCanvas.width, previewCanvas.height);
  } else {
    dctx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
  }
}

/* Process image for mask using MediaPipe */
async function processImageForMask(source){
  try {
    // MediaPipe accepts canvas or image
    await selfieSeg.send({image: source});
  } catch(err){
    console.error('Segmentation error', err);
    alert('Segmentation failed: ' + (err.message || err));
  }
}

/* onResults from MediaPipe */
async function onSegmentationResult(results){
  if (!results.segmentationMask) return;

  // Dimensions of resized working image
  maskW = workingImageCanvas.width;
  maskH = workingImageCanvas.height;

  // Extract mask from MediaPipe
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = maskW;
  maskCanvas.height = maskH;

  const mctx = maskCanvas.getContext('2d');
  mctx.drawImage(results.segmentationMask, 0, 0, maskW, maskH);

  const md = mctx.getImageData(0,0,maskW,maskH).data;
  maskFloat = new Float32Array(maskW * maskH);
  for (let i = 0, j = 0; i < md.length; i += 4, j++) {
    maskFloat[j] = md[i] / 255; // grayscale
  }

  // Clean up noise in mask
  maskFloat = morphClean(maskFloat, maskW, maskH, 1);

  // NOW â†’ upscale mask to full resolution original image
  const fullW = originalImg.naturalWidth;
  const fullH = originalImg.naturalHeight;

  const maskFull = resizeMaskFloat(maskFloat, maskW, maskH, fullW, fullH);

  // Convert original image â†’ canvas (full size)
  const fullCanvas = document.createElement("canvas");
  fullCanvas.width = fullW;
  fullCanvas.height = fullH;
  fullCanvas.getContext("2d").drawImage(originalImg, 0, 0, fullW, fullH);

  // Apply advanced matting on full resolution
  let matteImageData = advancedMatting(fullCanvas, maskFull, fullW, fullH);

// Feather blur for soft edges
boxBlurAlpha(matteImageData, fullW, fullH, 2);

// â­ NEW: remove bright/white color spill (halo fix)
removeColorSpill(matteImageData, fullW, fullH);
  // NEW: strongest halo cleanup
decontaminateEdges(matteImageData, fullW, fullH, 2);
  
  // Output canvas for preview (scaled)
  const outCanvas = document.createElement('canvas');
  outCanvas.width = fullW;
  outCanvas.height = fullH;
  const outCtx = outCanvas.getContext('2d');
  outCtx.putImageData(matteImageData, 0, 0);

  // Scale to preview
  const PREVIEW_MAX_W = Math.min(900, fullW);
  const scale = PREVIEW_MAX_W / fullW;

  previewCanvas.width = Math.round(fullW * scale);
  previewCanvas.height = Math.round(fullH * scale);

  ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
  ctx.imageSmoothingEnabled = true;

  ctx.drawImage(outCanvas, 0, 0, previewCanvas.width, previewCanvas.height);

  // â­ Important: store final output for download
  window.finalOutputCanvas = outCanvas;
}
  
/* simple morphological clean (dilate then erode) */
function morphClean(mask, w, h, radius){
  if(radius <= 0) return mask;
  const dil = new Float32Array(w*h);
  const r = radius;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let maxv = 0;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = mask[base + xx];
          if(v > maxv) maxv = v;
          if(maxv >= 1) break;
        }
        if(maxv >= 1) break;
      }
      dil[y*w + x] = maxv;
    }
  }
  const ero = new Float32Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let minv = 1;
      const j0 = (y-r) < 0 ? 0 : y-r;
      const j1 = (y+r) >= h ? h-1 : y+r;
      const i0 = (x-r) < 0 ? 0 : x-r;
      const i1 = (x+r) >= w ? w-1 : x+r;
      for(let yy=j0; yy<=j1; yy++){
        let base = yy*w;
        for(let xx=i0; xx<=i1; xx++){
          const v = dil[base + xx];
          if(v < minv) minv = v;
          if(minv <= 0) break;
        }
        if(minv <= 0) break;
      }
      ero[y*w + x] = minv;
    }
  }
  return ero;
}

/* Advanced matting:
   - originalCanvas: source image canvas (workingImageCanvas)
   - maskArray: Float32Array (0..1)
   - returns ImageData(width,height) with correct alpha (0..255)
*/
/* ---------- Remove.bg-style Clean Edge Matting (NO WHITE HALOS) ---------- */
function advancedMatting(originalCanvas, maskArray, width, height) {
  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = width;
  tmpCanvas.height = height;

  const tctx = tmpCanvas.getContext("2d");
  tctx.drawImage(originalCanvas, 0, 0, width, height);

  const src = tctx.getImageData(0, 0, width, height);
  const dst = tctx.createImageData(width, height);

  /* ----------------------------------------------------
     STEP 1 â€” Detect background color from corners
  -----------------------------------------------------*/
  let sumR = 0, sumG = 0, sumB = 0;
  const corners = [
    5 * width + 5,
    5 * width + (width - 5),
    (height - 5) * width + 5,
    (height - 5) * width + (width - 5)
  ];

  corners.forEach(i => {
    const idx = i * 4;
    sumR += src.data[idx];
    sumG += src.data[idx + 1];
    sumB += src.data[idx + 2];
  });

  const bgR = sumR / 4;
  const bgG = sumG / 4;
  const bgB = sumB / 4;

  /* ----------------------------------------------------
     STEP 2 â€” Halo-free alpha calculation
  -----------------------------------------------------*/
  for (let i = 0; i < width * height; i++) {
    const idx = i * 4;

    const r = src.data[idx];
    const g = src.data[idx + 1];
    const b = src.data[idx + 2];

    const base = maskArray[i] * 255; // soft alpha

    // Color distance from background
    const dist =
      Math.abs(r - bgR) +
      Math.abs(g - bgG) +
      Math.abs(b - bgB);

    let alpha = base;

    /* ----------------------------------------------------
       HALO REMOVAL: aggressively remove light edges
    -----------------------------------------------------*/
    if (dist < 70 && base < 230) {
      alpha = Math.max(0, base - 160);  // remove white halo
    }

    /* ----------------------------------------------------
       HARD EDGE SHRINK (1â€“2 px) â€“ eliminates outline
    -----------------------------------------------------*/
    if (base < 80) alpha = 0;

    /* ----------------------------------------------------
       ALPHA GAMMA (smooth clean edges like remove.bg)
    -----------------------------------------------------*/
    alpha = Math.pow(alpha / 255, 1.5) * 255; // tighter edge

    alpha = Math.min(255, Math.max(0, alpha));

    dst.data[idx] = r;
    dst.data[idx + 1] = g;
    dst.data[idx + 2] = b;
    dst.data[idx + 3] = alpha;
  }

  return dst;
}

/* lightweight box blur applied to alpha channel only */
function boxBlurAlpha(imageData, w, h, radius) {
  if(radius <= 0) return;
  const src = imageData.data;
  const tmp = new Uint8ClampedArray(src.length);
  tmp.set(src);

  // horizontal pass
  const window = radius*2 + 1;
  for(let y=0;y<h;y++){
    let sum = 0;
    // initial window
    for(let x=-radius; x<=radius; x++){
      const xi = clamp(x,0,w-1);
      sum += tmp[(y*w + xi)*4 + 3];
    }
    for(let x=0;x<w;x++){
      const dstIdx = (y*w + x)*4 + 3;
      src[dstIdx] = Math.round(sum / window);
      // slide window
      const outX = x - radius;
      const inX = x + radius + 1;
      if(outX >= 0) sum -= tmp[(y*w + outX)*4 + 3];
      if(inX < w) sum += tmp[(y*w + inX)*4 + 3];
    }
  }

  // vertical pass (use tmp as source, src as destination)
  tmp.set(src); // copy current alpha
  for(let x=0;x<w;x++){
    let sum = 0;
    for(let y=-radius; y<=radius; y++){
      const yi = clamp(y,0,h-1);
      sum += tmp[(yi*w + x)*4 + 3];
    }
    for(let y=0;y<h;y++){
      const dstIdx = (y*w + x)*4 + 3;
      src[dstIdx] = Math.round(sum / window);
      const outY = y - radius;
      const inY = y + radius + 1;
      if(outY >= 0) sum -= tmp[(outY*w + x)*4 + 3];
      if(inY < h) sum += tmp[(inY*w + x)*4 + 3];
    }
  }
}

  function removeColorSpill(imageData, width, height) {
  const d = imageData.data;
  const copy = new Uint8ClampedArray(d); // backup

  const brightnessThreshold = 190;
  const alphaThreshold = 40;

  for (let i = 0; i < d.length; i += 4) {
    const r = copy[i], g = copy[i+1], b = copy[i+2];
    const a = copy[i+3];

    const brightness = (r + g + b) / 3;

    if (brightness > brightnessThreshold && a < alphaThreshold) {

      let nr = 0, ng = 0, nb = 0, count = 0;

      const idxPixel = i / 4;
      const px = idxPixel % width;
      const py = Math.floor(idxPixel / width);

      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {

          const x = px + dx;
          const y = py + dy;
          if (x < 0 || y < 0 || x >= width || y >= height) continue;

          const ni = (y * width + x) * 4;
          const na = copy[ni + 3];

          if (na > 150) {
            nr += copy[ni];
            ng += copy[ni + 1];
            nb += copy[ni + 2];
            count++;
          }
        }
      }

      if (count > 0) {
        d[i]   = nr / count;
        d[i+1] = ng / count;
        d[i+2] = nb / count;
      }
    }
  }
}

  function decontaminateEdges(imageData, width, height, radius = 2) {
  const d = imageData.data;
  const copy = new Uint8ClampedArray(d);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {

      const i = (y * width + x) * 4;
      const a = copy[i + 3];

      // only treat semi-transparent edge region
      if (a > 180 || a === 0) continue;

      let rr = 0, gg = 0, bb = 0, cc = 0;

      // look inside object for clean color
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {

          const nx = x + dx;
          const ny = y + dy;

          if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;

          const ni = (ny * width + nx) * 4;
          const na = copy[ni + 3];

          // interior solid pixel = best reference
          if (na > 230) {
            rr += copy[ni];
            gg += copy[ni + 1];
            bb += copy[ni + 2];
            cc++;
          }
        }
      }

      // Replace edge color if we found a clean interior color
      if (cc > 0) {
        d[i]   = rr / cc;
        d[i+1] = gg / cc;
        d[i+2] = bb / cc;
      }
    }
  }
}

/* Warmup (non-blocking) */
(async function warmup(){
  const tmp = document.createElement('canvas');
  tmp.width = 10; tmp.height = 10;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = 'black'; tctx.fillRect(0,0,10,10);
  try {
    if(selfieSeg.initialize) await selfieSeg.initialize();
  } catch(e) {
    console.warn('Warmup failed', e);
  }
})();
</script>
</body>
</html>
